\documentclass[a4paper,11pt]{jreport}

\usepackage{times}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{braket}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}

\newtheorem{definition}{定義}
\newtheorem{theorem}{定理}
\renewcommand{\proofname}{証明}
\newcommand{\Continue}{\State \textbf{continue} }
\newcommand{\Break}{\State \textbf{break} }

\setcounter{tocdepth}{3}
\setcounter{page}{-1}

\setlength{\oddsidemargin}{0.1in}
\setlength{\evensidemargin}{0.1in} 
\setlength{\topmargin}{0in}
\setlength{\textwidth}{6in} 
\setlength{\parskip}{0em}
\setlength{\topsep}{0em}

\usepackage{sie-jp}

\title{単体上における非凸関数の大域的最適化}
\author{千葉 竜介}
\degree{修士（工学）}
\advisor{久野 誉人}

\majorfield{コンピュータサイエンス}
\yearandmonth{2017年 3月}

\begin{document}
\maketitle
\thispagestyle{empty}
\newpage

\thispagestyle{empty}
\vspace*{20pt plus 1fil}
\parindent=1zw
\noindent
\begin{center}
{\bf 概要}
\vspace{5mm}
\end{center}

% TODO: 応用例，過去の研究について述べる
凸関数最適化問題と比較して非凸関数の最適化は一般的に困難であると言われている．その中でも，非凸関数の一種である単調関数（Monotonic function）の最適化を扱う．単調関数とは，入力の増加に対して関数値も常に増加または減少する関数のことである．そのような単調関数について，実行可能領域を単体（Simplex）とした場合の最適化を考える．\par
本稿では，大域的最適化の手法としてよく利用されている分枝限定法を利用する．分枝限定法は実行可能領域の分割を繰り返し，たくさんの小さな問題を解く手法である．実行可能領域における関数値の下界と暫定解と比較することで，その領域に最適解が存在しうるかどうかを判断し，最適解が存在し得ない場合はその領域を削除して効率的に最適化を行う．したがって分枝限定法において，良い下界を与えること，効果的に実行可能領域を分割することは重要である．\par
単体の新たな分割方法の提案を行い，その分割手法が生成する子領域の数の上限を示す．さらに，提案した分割手法を使った分枝限定法の実験を行い，提案手法を評価する．\par

\par
\vspace{0pt plus 1fil}
\newpage

\pagenumbering{roman}
\tableofcontents
% \listoffigures
% \listoftables

\pagebreak
\setcounter{page}{1}
\pagenumbering{arabic}

\chapter{序論}
\section{概要}

% TODO: 応用例，過去の研究について述べる

\section{記号の定義}

\begin{table}[htb]
\begin{tabular}{ll}
表記 & 意味 \\ \hline
$ \mathbb{R} $ & 実数全体の集合 \\
$ \mathbb{R}^n $ & $ n $ 次元実数ベクトル全体の集合 \\
$ \mathbb{R}^n_{+} $ & すべての要素が非負である $ n $ 次元実数ベクトル全体の集合 \\
$ \mathbb{Z} $ & $ 0 $ を含む自然数全体の集合 \\
$ \mathbb{Z}^n $ & $ n $ 次元自然数ベクトル全体の集合 \\
$ e_i \; (e_i \in \mathbb{R}^n) $ & $ i $ 番目の要素が $ 1 $ でそれ以外が $ 0 $ であるような単位ベクトル \\
$ x_i \; (x \in \mathbb{R}^n) $ & ベクトル $ x $ の $ i $ 列目の要素 \\
$ x < y \; (x, y \in \mathbb{R}^n) $ & $ x_i < y_i \; (i = 1, ..., n) $ \\
$ x \leq y \; (x, y \in \mathbb{R}^n) $ & $ x_i \leq y_i \; (i = 1, ..., n) $
\end{tabular}
\end{table}


\section{構成}

第1章では本論文の概要の説明と記号の定義を行った．第2章では本論文で扱う問題の定義とその性質を論じる．第3章では提案手法に関連する研究の説明を行い，第4章で提案手法の説明を行う．第5章では数値実験の結果を紹介し，第6章で結論を述べる．

\chapter{単体上の単調関数最適化問題}

本研究で扱う問題は以下のような単調関数 $ f $ の最小化問題である．\par

$$
\left| \;
\begin{aligned} \label{primal_problem}
& 最小化 && f(x) &&&&& \\
& 条件 && \sum_{i=1}^n x_i = 1 \notag \\
& && x_i \geq 0, i = 1, ..., n \notag
\end{aligned}
\right.
$$

制約条件に，$ x $ の各要素の和が $ 1 $ であることと非負であることがある．このような条件を満たす $ x $ の集合は単体と呼ばれており，様々な研究がなされている．この問題は単調関数の単体上における最適化問題であり，まずは単調関数と単体を定義し，それらの性質について論ずる．\par

\section{単調関数}

単調関数とは，単調増加関数または単調減少関数のことであり，入力の増加に対して関数値も常に増加または減少する関数である．\\

\begin{definition}
$ I \subseteq \mathbb{R}^n $ の関数 $ f : I \to \mathbb{R} $ は任意の $ x, x' \in I $ に対して以下が成り立つ場合に単調増加関数であるという．
$$ x < x' \Rightarrow f(x) \leq f(x') $$
\end{definition}

\begin{definition}
$ I \subseteq \mathbb{R}^n $ の関数 $ f : I \to \mathbb{R} $ は任意の $ x, x' \in I $ に対して以下が成り立つ場合に単調減少関数であるという．
$$ x < x' \Rightarrow f(x) \geq f(x') $$
\end{definition}

ここで $ I $ は $ n $ 次元実数空間全体や区間，離散的な空間が考えられる．\\

\begin{theorem} \label{keeping_monotonicity}
$ f : I \to \mathbb{R} $ が単調増加関数であるとき，$ -f $ は単調減少関数である．逆も同様に成り立つ．
\end{theorem}

\begin{proof}
$ f $ は単調増加関数であるから，任意の $ x, x' \in I $ について以下が成り立つ．
\begin{align*}
& x < x' \Rightarrow f(x) \leq f(x') \\
\Longleftrightarrow \hspace{8pt} & x < x' \Rightarrow -f(x) \geq -f(x')
\end{align*}
これは $ -f $ が単調減少関数であることを示し，$ f $ が単調増加関数であることと，$ -f $ が単調減少関数であることが同値であることが証明された．
\end{proof}

定理 \ref{keeping_monotonicity} より，関数値を $ -1 $ 倍する操作によって単調増加と単調減少が切り替わり，単調性は失われないことがわかる．さらに，最適化問題において，ある関数 $ f $ の最大化は $ -f $ の最小化と同じであるため，関数値を $ -1 $ 倍することで最大化問題を最小化問題に変換することができる．ここからは単調増加関数の最小化問題についてしか論じないが，この通り最大化問題は最小化問題に変換することができ，単調性は保存されることから，一般性は失わない．\par

\section{単位単体}

\begin{definition}
以下を単位単体という．
$$ \Delta_n \triangleq \Set{ x \in \mathbb{R}^n_{+} | \sum_{i=1}^{n} x_i = 1 } $$
\end{definition}

$ n $ について具体的に考えてみると，$ n=2 $ のとき線分，$ n=3 $ のとき平面上の正三角形，$ n=4 $ のとき三角錐となることがわかる．このように $n$ に対して一次元減った図形になることから，先ほど定義した $n$ 次元の単位単体 $ \Delta_n $ は $ n-1 $ 単体と呼ばれる．\par

\section{単体上の単調関数の性質}

単調増加関数 $ f : \mathbb{R}^n_{+} \to \mathbb{R} $ の単位単体上における性質について考える．まず，単体の定義から以下が成り立つ．\\

\begin{theorem}
単体上の任意の点 $ x, y \in \Delta_n $ について $ x < y $ が成り立つことはない．
\end{theorem}

\begin{proof}
背理法で示す．$ x < y $ となるような $ x, y $ が $ \Delta_n $ 中に存在すると仮定する．\\
$ x < y $ であるから，
\begin{align}
& x_i < y_i \;, i = 1, ..., n \notag \\
\Longrightarrow \hspace{8pt} & \sum_{i=1}^n x_i < \sum_{i=1}^n y_i \notag
\end{align}
これは $ x, y \in \Delta_n $ つまり，$ \sum_{i=1}^n x_i = \sum_{i=1}^n y_i = 1 $ に矛盾する．\\
よって，$ x < y $ が成り立つような単体上の点 $ x, y $ は存在しないことが証明された．
\end{proof}

つまり，単調増加関数の唯一の性質である $ x < y \Rightarrow f(x) < f(y) $ を利用できる点が単体上には存在せず，単体上だけを見ると特に性質のない任意の関数であるように見える．以上のことから，単体上における単調関数の最適化は一般的な大域的最適化問題を解くことと同程度に困難であると予想される．\par
しかし，実行可能領域以外の領域の情報を利用し，単体上における下界を得ることができる．\\

\begin{theorem}\label{lower_bound_of_monotonic_function}
以下のような要素を持つ $ x_{LB} \in \mathbb{R}^n_{+} $ は単体の任意の部分領域 $ A \subseteq \Delta_n $ における単調増加関数 $ f :  \mathbb{R}^n_{+} \to \mathbb{R} $ の関数値の下界 $ f(x_{LB}) $ を与える．
$$ (x_{LB})_i = \min_{y \in A } y_i \; , \; i = 1, ..., n $$
\end{theorem}

\begin{proof}
$ x_{LB} $ の生成方法より，$ A $ の任意の要素 $ x $ について $ x_{LB} \leq x $ が成り立つ．\\
また，$ f $ は単調増加関数であったから，$ \forall x, y \in \mathbb{R}^n_{+}, x < y \Rightarrow f(x) < f(y) $ が成り立ち，
$$ \forall x \in A, f(x_{LB}) \leq f(x) $$
よって，$ f(x_{LB}) $ は単体の任意の部分領域 $ A $ における単調増加関数 $ f $ の下界となる．
\end{proof}

\chapter{関連研究}

\section{分枝限定法}

分枝限定法とは，大域的最適化の汎用アルゴリズムであり，広く利用されている．実行可能領域を分割し，それぞれの分割された領域に対して下界値・上界値を求め，それらや暫定最適値を比較することで最適解が存在し得ない領域を削除し，探索する領域を絞り込む．以上を繰り返して効率的に探索をする最適化手法である．\par
最小化問題を解く場合の一般的なアルゴリズムとして分枝限定法の説明を行う．分枝限定法は大きく分けて分枝・限定の2種類の操作から成る．分枝操作では，実行可能領域から領域 $ S $ を選択し，$ S_1 \cup S_2 \cup ... \cup S_n = S, S_1 \cap S_2 \cap ... \cap S_n = \phi $ を満たす $ n $ 個の部分領域に分割する．分割の方法や分割数はアルゴリズムによって異なり，問題に対して適した手法を考えることが重要である．次に限定操作では，それぞれの部分領域について下界値を求める．その下界値が，他の領域の上界値よりも大きい場合や，暫定最適値よりも大きい場合はその部分領域に最適解が存在し得ないため，その領域の探索を打ち切る．ある領域の探索を打ち切り，削除することを刈り込みと呼ぶ．領域の刈り込みを効率的に行うには，よい下界，上界を得ること，探索中に素早くよい暫定最適値を見つけることが重要である．以上の操作をすべての領域を刈り込むまで繰り返し実行し，その時点の最適値を問題の最適値として出力する．\par

\section{単体のグリッド化}

de Klerk \cite{deklerk} などにより，単体をグリッド化して探索を行う研究がされている．ここでグリッド化とは，単体の内部に格子を考え，格子の交差点だけを抽出し，単体の内部に等間隔に存在する点群を得ることである．グリッド化によって実行可能領域は小さくなり，解きやすくなる．まずは単体のグリッド化の定義を行う．\par
$ m \in \mathbb{Z} $ を利用して，$ n $ 次元の単位単体の各辺を $ m $ 分割して得られるグリッド化された単位単体は以下のように表せる．
$$ \Set{ x \in \Delta_n | mx \in \mathbb{Z}^n } $$
これまでは単位単体のみを扱ってきたが，正の実数 $ c $ を利用して，各辺の長さが $ c $ であるような単体 $ c \Delta_n $ をグリッド化したもの $ G(c, n, m) $ を以下のように定義する．\par
\begin{definition}
$$ G(c, n, m) \triangleq c \Delta_n \cap \Set{x \in \mathbb{R}^n | mx \in \mathbb{Z}^n} $$
\end{definition}
ここで，$ c = 1 $ としたとき，$ G(1, n, m) $ は $ n $ 次元の単位単体の各辺を $ m $ 等分してグリッド化したものと同じであることがわかる．\par
% TODO: $ n = 3, m = 5 $ のときのグリッド化された単体の図を描く
TODO: $ n = 3, m = 5 $ のときのグリッド化された単体の図を描く\par

\begin{theorem} \label{n_grid}
グリッド化された単位単体 $ G(1, n, m) $ が持つ点の数は二項係数を利用した以下で与えられることがわかっている．
$$ | G(1, n, m) | = \binom{n + m - 1}{m} $$
\end{theorem}

これは $ m $ を固定した場合の $ n $ の多項式であり，最適化手法としてグリッド化した単体上を全探索しても $ n $ の多項式オーダーでアルゴリズムが完了することがわかる．しかし，もちろん $ n, m $ を大きくした場合の $ \binom{n + m - 1}{m} $ はとても大きい数であり，例えば $ n = 10, m = 100 $ の場合，生成される点の数はおよそ $ 8.5 \times 10^{12} $ であり，全探索は難しいと容易に想像できる．\par

\section{単体の分割} \label{partition}

% TODO: わかりやすい図を描く
TODO: わかりやすい図を描く\par
分枝限定法の分枝操作では実行可能領域をいくつかの部分領域に分割するが，本問題の実行可能領域は単体であるから，単体を分割する手法を考える．さらに，分枝操作は繰り返し行われるため，分割された部分領域も同様にすべて単体となっている必要がある．\par
外崎ら \cite{tonosaki} による単体の分割手法は，グリッド化された単体を一次元少ない単体と，一列少ない単体の二つに分割する方法である．この手法を具体的に説明する．\par
$ mb \in \mathbb{Z}^n $ を満たすような非負ベクトル $ b \in \mathbb{R}^n_{+} $ を利用して $ c $ を次のように与える．
$$ c \equiv 1 - \sum_{j=1}^{n} b_j > 0 $$
このとき次元のインデックスの部分集合 $ K = \{j_1, ..., j_k\} \subset \{1, ..., n\} $ を選択すると，単体上の最小化問題である元の問題 \ref{primal_problem} の部分問題を以下のように定義することができる．\par

$$
P(K, b) \;
\left| \;
\begin{aligned}
& 最小化 && f(x) \\
& 条件 && \sum_{j = 1}^n x_j = 1 \\
& && mb_j \leq mx_j \in \mathbb{Z}, && j \in K \\
& && x_j = b_j, && j \not \in K
\end{aligned}
\right.
$$

$ K $ に選択されなかった次元は $ b $ の値に固定され，$ K $ に選択された次元の変数のみを変数とするような問題となる．この問題は以下の問題と等価である．\par

$$
\left| \;
\begin{aligned}
& 最小化 && f(x) \\
& 条件 && y \in G(c, k, m) \notag \\
& && y_i = x_{j_i} - b_{j_i}, && j = 1, ..., k \notag \\
& && x_j = b_j, && j \not \in K \notag
\end{aligned}
\right.
$$

この問題は各辺の大きさが $ c $ である $ k $ 次元のグリッド化された単体上の問題である．さらに定義より，$ G(c, k, m) $ は各辺を $ mc $ 個に分割したグリッドの集合であり，定理 \ref{n_grid} より以下が成り立つ．
$$ |G(c, k, m)| = \binom{k + mc -1}{mc} $$
次に，$ K $ から一つのインデックス $ j_k $ を選択し $ P(K, b) $ を二つの部分問題に分割する．\par

$$
P(K, b + e_{j_k} / m) \;
\left| \;
\begin{aligned}
& 最小化 && f(x) \\
& 条件 && \sum_{j = 1}^n x_j = 1 \\
& && mb_j \leq mx_j \in \mathbb{Z}, && j \in K \backslash \{ j_k \} \\
& && mb_{j_k} + 1 \leq mx_{j_k} \in \mathbb{Z} \\
& && x_j = b_j, && j \not \in K
\end{aligned}
\right.
$$

$$
P(K \backslash \{ j_k \}, b) \;
\left| \;
\begin{aligned}
& 最小化 && f(x) \\
& 条件 && \sum_{j = 1}^n x_j = 1 \\
& && mb_j \leq mx_j \in \mathbb{Z}, && j \in K \backslash \{ j_k \} \\
& && x_j = b_j, && j \not \in K \\
& && x_{j_k} = b_{j_k}
\end{aligned}
\right.
$$

これらはそれぞれ以下の2問題と同値である．\par

$$
\left| \;
\begin{aligned}
& 最小化 && f(x) \\
& 条件 && y \in G(c - 1/m, k, m) \notag \\
& && y_i = x_{j_i} - b_{j_i}, && i = 1, ..., k-1 \notag \\
& && y_k = x_{j_k} - b_{j_k} - 1 / m \notag \\
& && x_j = b_j, && j \not \in K \notag
\end{aligned}
\right.
$$

$$
\left| \;
\begin{aligned}
& 最小化 && f(x) \\
& 条件 && y \in G(c, k - 1, m) \notag \\
& && y_i = x_{j_i} - b_{j_i}, && i = 1, ..., k-1 \notag \\
& && x_j = b_j, && j \not \in K \notag \\
& && x_{j_k} = b_{j_k} \notag
\end{aligned}
\right.
$$

$ P(K, b + e_{j_k} / m) $ は $ P(K, b) $ からグリッドが一列減った問題であり，$ P(K \backslash \{ j_k \}, b) $ は次元が1次元減った問題である．以上のようにグリッド化された単体を，一列減った単体と一次元減った単体に分割することができた．もともと単体には一列という概念は存在しないが，グリッド化をしたことによってこのような操作が可能になった．さらに，これらの定義域のグリッド化された単体のグリッド数について見てみると，以下がわかる．
$$ | G(c - 1/m, k, m) | = \binom{k + mc - 2}{mc - 1} $$
$$ | G(c, k - 1, m) | = \binom{k + mc - 2}{mc} $$
二項係数の性質として以下が知られている．
$$ \binom{k + mc - 1}{mc} = \binom{k + mc - 2}{mc - 1} + \binom{k + mc - 2}{mc} $$
ゆえに，以下が成り立つ．
$$ | G(c, k, m) | = | G(c - 1/m, k, m) | + | G(c, k - 1, m) | $$
この分枝操作を繰り返すと，すべてのグリッド化された単体はただ一点のみを含む単体になり，その総数は $ \binom{k + mc - 1}{mc} $ となる．\par
元の問題 \ref{primal_problem} から分枝操作を繰り返すことで，問題をノードに持つ二分木 $ T $ を考えることができ，その木の葉は一点のみを含む単体となる．この二分木のノード数について以下のことが言える．\\

\begin{theorem}
$ T $ の総ノード数は $ 2 \binom{n + m - 1}{m} - 1 $ である
\end{theorem}
\begin{proof}
帰納的に示す．$ r = \binom{n + m - 1}{m} $ とおく．$ q < r $ であるような $ q $ に対して，$ q $ を葉の総数とする二分木のノード数は $ 2q - 1 $ であると仮定する．\\
次に $ T $ の根を親に持つような二つの部分木を $ T_1, T_2 $ とし，それらの葉の数を $ r_1, r_2 $ とすると，$ r = r_1 + r_2 $ が成り立つ．さらに，$ r_1, r_2 \leq r - 1 $ であるから仮定より，$ T_1, T_2 $ のノード数は $ 2r_1 - 1, 2r_2 - 1 $ である．\\
よって，$ T $ のノード数は
$$ (2r_1 - 1) + (2r_2 - 1) + 1 = 2(r_1 + r_2) - 1 = 2r - 1 $$
\end{proof}

\section{単調関数の最適化}

% TODO: 書く
TODO: 書く\par
Tuy による，単調関数の最適化．\par

\chapter{提案手法}

単体上の単調関数を分枝限定法で最適化する．分枝限定法において，領域の分割方法，下界の良さはアルゴリズムの速度に対して大変重要であり，本研究では単調関数の下界に定理  \ref{lower_bound_of_monotonic_function} で得られるものを利用し，分割方法は \ref{partition} 節で説明したもの利用する．\par

\section{分割する次元の選択}

% TODO: わかりやすくなる絵を描く
TODO: わかりやすくなる絵を描く\par
分枝限定法において，分割された部分問題が良い関数値を持つことは，その部分領域が良い下界を持つことにつながり，その下界によってその領域を削除しやすくなる．さらに，良い暫定解を得ることにもつながるため，部分問題が良い関数値を持つことはアルゴリズムの早い収束に対して重要である．本節では，分割された部分領域が良い関数値を持つようにするための，分割する次元の決定方法について論じる．\par
\ref{partition} 節の $ P(K, b) $ では，元の変数 $ x $ の代わりに $ y \in G(c, k, m) $ となるような変数 $ y $ が取り直されている．$ G(c, k, m) $ は次元のインデックス $ j_k $ を選択することで二つの部分単体 $ G(c, k-1, m), \; G(c-1/m, k, m) $ に分割される．選択された $ j_k $ 次元の値について詳しく見てみると，$ G(c, k - 1, m) $ では $ j_k $ 次元の変数値 $x_{j_k} $ は $ b_{j_k} $ に固定されており，これに対応する $ y \in G(c, k, m) $ における変数値 $ y_k $ は最小値 $ 0 $ となる．\par
本問題で扱っている関数は単調増加関数であるから，ある次元 $ k $ に着目したとき，$ y_k $ が大きくなれば関数値は単調に増加し，逆に $ y_k $ が小さくなれば関数値は単調に減少する．よって，関数値に対して大きなインパクトを与えている次元 $ k $ を探し出し，$ k $ 次元について単体を分割すると，$ k $ 次元の値が最小値に固定された部分問題 $ P(K \backslash \{ k \}, b) $ の関数値は小さくなると予想できる．\par
次に，大きなインパクトを与えている次元 $ k $ の探し方を考える．$ G(c, k, m) $ の頂点の集合を考えると，それらは $ c $ 倍した $ k $ 次の単位行列 $ I $ の列を取り出したものとなっている．つまり，頂点の要素は以下のようになっている．
$$ (c, 0, 0, ..., 0), (0, c, 0, ..., 0), (0, 0, c, ..., 0), ..., (0, 0, 0, ..., c) $$
ある次元 $ i $ に着目すると，$ i $ 番目の頂点の $ i $ 番目の要素は $ c $ で，それ以外の頂点の $ i $ 番目の要素は $ 0 $ である．ここで，全ての頂点について関数値を調べ，最も悪い関数値を持った頂点を $ j $ 番目の頂点であるとする．ここで，関数の単調性を考えてみると，頂点の $ j $ 番目の要素のインパクトが大きいために関数値が悪くなっているのではないかと予想できる．そこで，次元 $ j $ について単体を分割し，$ j $ 次元の変数値を最小値に固定した部分領域を切り出すことで，部分問題の関数値を小さくしたい．\par
疑似コードを Algorithm \ref{algo:cutting_dimension} に示した．\par

\begin{algorithm}
\caption{Decide cutting dimension of simplex}
\label{algo:cutting_dimension}
\begin{algorithmic}[1]
\Function{DecideCuttingDimension}{simplex}
\State Initialize $ worst\_value $
\State Initialize $ dimension $
\For{each $ vertex $ of $ simplex $}
\State $ function\_value := \Call{ObjectiveFunctionValue}{vertex} $
\If{$ function\_value \geq worst\_value $}
\State $ worst\_value := function\_value $
\State $ dimension := \Call{GetDimension}{vertex} $
\EndIf
\EndFor
\State \Return $ vertex $
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{単体の保持}

分枝限定法において，分割される元の領域を親ノードとし，分割によって生成される複数の部分領域を子ノードと考えると，分割は木構造となる．ここで，根ノードは元の問題の実行可能領域であり，アルゴリズムが進行するにつれてすべての葉ノードは分割され，木は大きくなる．\par
\ref{partition} 節の手法は単体を二つの部分単体に分割するため，二分木の構造を持つ．根ノードを単位単体としてアルゴリズムを開始し，その時点での葉ノード全てについて分割を繰り返すため，葉ノードの数は指数的に増大する．ゆえに大きなサイズの問題を解く場合，コンピュータのメモリ上に全ての葉ノードオブジェクトを保持し続けることは困難となる．この問題を解決するために，すべての葉ノードを保持するのでなく，分割の情報を表現する二分木を保持し，葉ノードが表す部分単体はその都度二分木の情報から再生成する．\par

\subsection{二分木の構成}

二分木のそれぞれのノードは単体を表現し，単体を分割するときにその単体を分割した次元をノードに保存する．分割によって二つの部分単体が生成されるが，一列減った部分単体は左の子ノードに，一次元減った部分単体は右の子ノードに挿入する．以上のルールに従って二分木を構成することで，二分木に保持された情報から，ある葉ノードの単体の形状を復元することができる．\par
% TODO: 図を描く
TODO: 図を描く\par

\subsection{単体の再生成}

% TODO: 逆順でも正しく生成できるのか確認する
二分木の情報から，葉ノードが表す単体の形状を再現する．調べたい葉ノードから根ノードまで，親ノードをたどる．その際，左右どちらの子ノードであるかの情報と分割された次元を取得し，その二つの情報から葉ノードの形状を一意に再現できる．疑似コードを Algorithm \ref{algo:regenerate_simplex_from_btree} に示した．\par

\begin{algorithm}
\caption{Regenerate the simplex from the binary tree}
\label{algo:regenerate_simplex_from_btree}
\begin{algorithmic}[1]
\Function{RegenerateSimplex}{$ node $}
\State $ simplex := \Call{GenerateUnitSimplex} $
\While{$ parent := \Call{parent}{node} $}
\State $ cutting\_dimension := binary\_tree[parent] $
\If{$ node $ is left child node}
\State $ simplex := \Call{CutOneRow}{simplex, cutting\_dimension} $
\ElsIf{$ node $ is right child node}
\State $ simplex := \Call{CutOneDimension}{simplex,  cutting\_dimension} $
\EndIf
\State $ node := parent $
\EndWhile
\State \Return $ simplex $
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{低次元の単体の処理}

アルゴリズムが進行するにつれ，分割された単体の次元は小さくなる．そして，分割された単体の情報が保持される二分木を考えてみると，木の末端に近い部分では低次元の単体しか存在せず，木の末端に近いということはそれらの数がとても多いことが容易に想像できる．よって，低次元の単体を効率良く処理することはアルゴリズムの速度に対して重要である．\par
外崎ら \cite{tonosaki} による研究では単体が1次元 (点) になるまで分割を行っていた．例えば2次元の単体 (線分) を分割するとき，その単体は一次元減った単体 (点) と一点が取り除かれた単体 (線分) に分割される．下界によって刈られる場合を除き，この処理を単体の分割数回 ($ m $ 回) 繰り返すことによってやっと全ての単体が点となりアルゴリズムが終了する．分割を繰り返すことでアルゴリズムのオーバーヘッドはかさむため，低次元の単体を単純なアルゴリズムで探索し，速度を向上したい．低次元の単体一つ一つにおける実行時間の改善は小さいものであるが，本手法で生成される低次元の単体の数はとても多いため，アルゴリズム全体として速度の大幅な改善が期待される．\par
分割が進み，単体の次元が2次元になった場合は単純に全てのグリッドの関数値を評価する．この処理は，部分単体が $ m $ 分割されている場合は $ O(m) $ の処理となる．疑似コードを Algorithm \ref{algo:line_search} に示した．\par

\begin{algorithm}
\caption{Line search}
\label{algo:line_search}
\begin{algorithmic}[1]
\Function{LineSearch}{$ line $}
\For{each $ point $ of $ line $}
\State $ function\_value := \Call{ObjectiveFunctionValue}{point} $
\If{$ function\_value < current\_optima $}
\State $current\_optima := function\_value $
\EndIf
\EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{アルゴリズム}

疑似コードは Algorithm \ref{algo:main} に示した通りとなる．\par

\begin{algorithm}
\caption{Optimize monotonic function on simplex}
\label{algo:main}
\begin{algorithmic}[1]
\State Initialize $ binary\_tree $
\State Initialize $ current\_optima $
\State $ i $ := 0
\While{$ true $}
\State $ nodes := i $ th row of $ binary\_tree $
\If{$ nodes $ are empty}
\Break
\EndIf
\For{each $ node $ of $ nodes $}
\State $ simplex = \Call{RegenerateSimplex}{node} $
\State $ lower\_bound := \Call{CalculateLowerBound}{simplex} $
\If{$ current\_optima \leq lower\_bound $}
\Continue
\EndIf
\If{$ simplex $ is a line}
\State $ \Call{LineSearch}{simplex} $
\Continue
\EndIf
\If{$ current\_optima \geq $ some vertices of $ simplex $}
\State Replace $ current\_optima $
\EndIf
\State $ cutting\_dimension = \Call{DecideCuttingDimension}{simplex} $
\State $ binary\_tree[node] := cutting\_dimension $
\EndFor
\EndWhile
\State \Return $ current\_optima $
\end{algorithmic}
\end{algorithm}

\section{並列化}

本アルゴリズムの並列化について述べる．分割した実行可能領域を保持する二分木における，同一列中のノードに相互に依存性はないため，列ごとに処理が完了していることを保証すればアルゴリズムを並列化できる．Algorithm \ref{algo:cutting_dimension} によってノードを分割する次元を計算したり，Algorithm \ref{algo:line_search} によって線形探索をしている間に，他のノードの処理をすることができるためアルゴリズム全体に対して速度の向上が図れるかもしれない．\par
ただし，$ G(1, n, m) $ を実行可能領域とする問題に対して，Algorithm \ref{algo:cutting_dimension} のオーダーは高々 $ O(n) $ で，Algorithm \ref{algo:line_search} は高々 $ O(m) $ であるため，それほど重い処理ではない．よって問題の大きさによっては，大きな速度の改善が見られない，もしくは改悪することも考えうる．\par
具体的には，Algorithm \ref{algo:main} における 10 - 23 行目を並列化できる．

\chapter{数値実験}

% TODO: 書く
TODO: 書く
\section{条件}
\section{実験結果}

\chapter{結論}

% TODO: 書く
TODO: 書く

\chapter*{謝辞}
\addcontentsline{toc}{chapter}{\numberline{}謝辞}

% TODO: 書く
TODO: 書く

\newpage

\addcontentsline{toc}{chapter}{\numberline{}参考文献}
\renewcommand{\bibname}{参考文献}

\begin{thebibliography}{1}

% TODO: 引用の仕方を統一する
\bibitem{tuy}
H. Tuy,
\newblock Monotonic optimization: Problems and solution approaches,
\newblock SIAM Journal on Optimization 11.2 (2000), pp. 464-494.

\bibitem{deklerk}
de Klerk E,
\newblock The complexity of optimizing over a simplex, hypercube or sphere: a short survey,
\newblock Central European Journal of Operations Research 16.2 (2008), pp. 111-125.

\bibitem{tonosaki}
外崎真造, 久野誉人,
\newblock 非凸2次制約付き配合計画問題のロバスト最適化,
\newblock 筑波大学システム情報工学研究科修士学位論文 (20010)
\end{thebibliography}

\end{document}
